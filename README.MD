# Singletons et gestion des utilisateurs avec Spring

## Introduction

Spring est fondamentalement bas√© sur des singletons - ces instances de classes uniques partag√©es √† travers toute l'application üîÑ. Cette approche est au c≈ìur du fonctionnement du framework, comme le confirme la [documentation officielle de Spring](https://docs.spring.io/spring-framework/reference/core/beans/factory-scopes.html).

Dans le contexte d'une API REST, ce principe implique que deux utilisateurs distincts interagissent avec la m√™me instance d'un contr√¥leur. Ce fonctionnement soul√®ve une question cruciale : comment r√©cup√©rer et traiter les informations sp√©cifiques √† chaque utilisateur tout en pr√©servant la confidentialit√© des donn√©es ?

Heureusement, Spring Security et son composant SecurityContextHolder offrent une solution √©l√©gante √† ce d√©fi technique.

## Niveau 1 : Le traitement g√©n√©rique sans authentification

### Sc√©nario 1 :
En tant qu'utilisateur quelconque,  
Lorsque j'envoie une requ√™te HTTP : `GET /bienvenue`  
Je veux recevoir "bienvenue !"

### Impl√©mentation

Gr√¢ce √† l'auto-configuration de Spring Boot ‚ú®, une seule d√©pendance est n√©cessaire :
```xml
<dependency>  
    <groupId>org.springframework.boot</groupId>  
    <artifactId>spring-boot-starter-web</artifactId>  
</dependency>
```

Ensuite, il suffit de cr√©er le contr√¥leur et la m√©thode qui r√©pondra √† notre requ√™te HTTP :
```java
@RestController  
public class AccueilController {  
    @GetMapping("/bienvenue")  
    public String accueillir() {  
       return "bienvenue !";  
    }  
}
```

R√©sultat du test : ‚úÖ

### Explication :
Examinons ce qui se passe en coulisses :

1. L'annotation `@RestController` permet √† Spring Boot de marquer la classe `AccueilController` comme bean. Lors du d√©marrage de l'application, Spring cr√©e **une seule** instance de la classe `AccueilController`. Cette instance unique est cr√©√©e et enregistr√©e dans l'ApplicationContext - le conteneur principal qui g√®re tous les beans Spring.

> **Pourquoi une seule instance?** L'annotation `@RestController` inclut implicitement `@Component`, l'un des [st√©r√©otypes fondamentaux de Spring](https://docs.spring.io/spring-framework/reference/core/beans/classpath-scanning.html#beans-stereotype-annotations). Par d√©faut, Spring utilise le scope singleton pour ces composants.

2. Toujours lors du d√©marrage : Spring cr√©e un mapping entre la requ√™te HTTP "GET /bienvenue" et la m√©thode `AccueilController::accueillir`.

3. Lors de notre test, la requ√™te "GET /bienvenue" est re√ßue par l'application. Gr√¢ce au mapping √©tabli pr√©c√©demment, la m√©thode de l'instance unique du contr√¥leur est appel√©e.

> Pour acheminer la requ√™te vers la m√©thode appropri√©e, Spring impl√©mente le [design pattern Front Controller](https://www.baeldung.com/spring-controllers) via la classe `DispatcherServlet`. Cette classe centrale agit comme un aiguilleur üö¶ qui dirige chaque requ√™te vers le bon contr√¥leur.

## Niveau 2 : Le traitement sp√©cifique par utilisateur

### Sc√©nario 2A :
En tant qu'utilisateur Aboubakar,  
Lorsque j'envoie une requ√™te HTTP : `GET /bienvenue`  
Je veux recevoir "bienvenue Aboubakar !"

### Sc√©nario 2B :
En tant qu'utilisatrice B√©atrice,  
Lorsque j'envoie une requ√™te HTTP : `GET /bienvenue`  
Je veux recevoir "bienvenue B√©atrice !"

### Impl√©mentation

Nous introduisons maintenant la notion d'utilisateur authentifi√© !
üîê Spring Security devient essentiel pour cette fonctionnalit√©.

Voici notre plan d'impl√©mentation √©tape par √©tape :
- Adapter le socle de notre application
- D√©clarer des utilisateurs autoris√©s √† se connecter
- Prot√©ger nos endpoints sensibles contre les intrus
- Authentifier nos utilisateurs lors des appels
- R√©cup√©rer les informations de l'utilisateur connect√©

#### 1. Adapter le socle

Pour ajouter Spring Security, il suffit d'inclure la d√©pendance suivante dans le `pom.xml` :

```xml
<dependency>  
    <groupId>org.springframework.boot</groupId>  
    <artifactId>spring-boot-starter-security</artifactId>  
</dependency>
```

> **Attention** : Dans ce projet, j'utilise la version 3.3.x de Spring Boot. Il se peut que d'autres √©tapes soient n√©cessaires si vous utilisez des versions ant√©rieures (comme ajouter une configuration `@EnableWebSecurity`).

#### 2. D√©clarer des utilisateurs

> **Attention** : √Ä ne jamais faire en production ! Dans cette application de d√©monstration, nous d√©clarons simplement deux utilisateurs de test : Aboubakar et B√©atrice.

```java
@Configuration  
public class SecurityConfig {  
    @Bean  
    public UserDetailsService users() {  
       return new InMemoryUserDetailsManager(  
             User.builder()  
                   .username("beatrice")  
                   .password("{noop}password")  
                   .build(),  
             User.builder()  
                   .username("aboubakar")  
                   .password("{noop}password")  
                   .build()  
       );  
    }
}
```

#### 3. Prot√©ger les endpoints

En r√©alit√©, nul besoin de faire un changement sp√©cifique pour prot√©ger nos endpoints. Le simple fait d'ajouter la d√©pendance Spring Security au projet ferme automatiquement les endpoints de l'application aux utilisateurs non authentifi√©s ! Comme le dit la [documentation officielle](https://docs.spring.io/spring-boot/docs/2.0.x/reference/html/boot-features-security.html) :

> "If Spring Security is on the classpath, then web applications are secured by default."

Cette s√©curit√© par d√©faut illustre parfaitement le principe "convention over configuration" de Spring Boot ! üõ°Ô∏è

#### 4. Authentifier des utilisateurs lors des appels

Place aux HTTP headers ! Si vous utilisez un outil de requ√™te HTTP comme Insomnia ou Postman, il suffit de renseigner l'onglet "Auth". Cela cr√©e automatiquement un header "Authorization" avec la valeur "Basic XXX" :
![insomniaSecured.png](annexe/insomniaSecured.png)

La structure du header est la suivante :
- "Basic " : indique la m√©thode d'authentification utilis√©e ([Basic](https://en.wikipedia.org/wiki/Basic_access_authentication), [Bearer](https://en.wikipedia.org/wiki/OAuth)...)
- La cha√Æne "YWJvdWJha2FyOnBhc3N3b3Jk" repr√©sente simplement notre paire utilisateur/mot de passe encod√©e en base64, conform√©ment √† la [sp√©cification HTTP](https://developer.mozilla.org/fr/docs/Web/HTTP/Authentication).

#### 5. R√©cup√©rer les informations de l'utilisateur

Voici comment acc√©der √† l'identit√© de l'utilisateur connect√© :

```java
@RestController  
public class UserDataController {  
  
    @GetMapping("/quisuisje")  
    public ResponseEntity<String> whoami() {  
       UserDetails userConnecte = (UserDetails) SecurityContextHolder  
             .getContext()  
             .getAuthentication()  
             .getPrincipal();  
       return ResponseEntity.ok(userConnecte.getUsername());  
    }  
}
```

(wip...)

## Conclusion

Mission accomplie ! ‚úÖ En quelques √©tapes seulement, nous avons transform√© notre application g√©n√©rique en une application capable d'identifier et de personnaliser l'exp√©rience de chaque utilisateur.

Spring Security nous offre un m√©canisme robuste pour g√©rer l'authentification et l'autorisation, tout en respectant le principe fondamental des singletons qui caract√©rise le framework Spring. Le `SecurityContextHolder` fonctionne comme un [contexte de s√©curit√© thread-local](https://docs.spring.io/spring-security/reference/servlet/authentication/architecture.html#servlet-authentication-securitycontextholder) qui pr√©serve l'identit√© de l'utilisateur courant pour chaque requ√™te trait√©e.

Pour enrichir davantage vos applications, n'h√©sitez pas √† explorer les fonctionnalit√©s avanc√©es de Spring Security :
- Gestion des r√¥les et des autorisations
- Authentification OAuth2
- Tokens JWT
- Protection CSRF
- Sessions s√©curis√©es

üìù **Important** : En environnement de production, certaines bonnes pratiques sont essentielles :
- Ne jamais stocker de mots de passe en clair
- Utiliser des connexions HTTPS syst√©matiquement
- Impl√©menter un m√©canisme de gestion des mots de passe robuste
- Effectuer des audits de s√©curit√© r√©guliers
- Maintenir les d√©pendances √† jour

Cette d√©monstration illustre parfaitement comment Spring r√©sout √©l√©gamment le paradoxe entre un mod√®le d'ex√©cution bas√© sur des singletons partag√©s et la n√©cessit√© de traiter des donn√©es sp√©cifiques √† chaque utilisateur.